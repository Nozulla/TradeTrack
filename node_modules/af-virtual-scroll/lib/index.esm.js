import t from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";

import { useRef as s, useReducer as e, useEffect as i, Fragment as o, useState as r, useImperativeHandle as h, memo as n, useCallback as l, cloneElement as a } from "react";

import c from "prop-types";

import { jsxs as d, jsx as u } from "react/jsx-runtime";

const f = t => t + 1, m = (t, o, r) => {
    const h = s(null), n = e(f, 0)[1];
    return i((() => (t.on(n, ...r), () => t.off(n, ...r))), r), 0 === t.t ? h.current = o(t) : 
    /*
        Somebody tried to rerender, while we were in batch.
        On batch finish component definitely must be rerendered.
    */
    t.i(n), h.current;
}, p = 0, w = 1, g = 2, R = "VXMoQIx", _ = [ "model", "children", "Spacer" ], b = [ 0 ], C = ({m: t, r: s, e: e}) => m(t, (({from: t, to: i}) => {
    const o = [];
    for (let r = t; r < i; r++) o.push(s(r, e));
    return o;
}), b), x = s => {
    let {model: e, children: i, Spacer: r = "div"} = s, h = t(s, _);
    /*#__PURE__*/
    return d(o, {
        children: [ /*#__PURE__*/ u(r, {
            className: R,
            "aria-hidden": "true",
            ref: e.o
        }), /*#__PURE__*/ u(C, {
            m: e,
            r: i,
            e: h
        }) ]
    });
}, y = (t, s) => s ? `${t} ${s}` : t;

const v = new Map, H = new ResizeObserver((t => {
    for (const {target: s} of t) {
        const t = v.get(s);
        t && t(s);
    }
})), N = (t, s) => {
    v.set(t, s), H.observe(t, {
        box: "border-box"
    });
}, M = t => v.delete(t) && H.unobserve(t);

class S extends class {
    constructor() {
        this.h = Array.from({
            length: 2
        }, (() => [])), this.l = new Set, this.t = 0;
    }
    on(t, ...s) {
        for (const e of s) this.h[e].push(t);
        return this;
    }
    u() {
        for (const t of this.h) t.splice(0);
        this.l.clear();
    }
    off(t, ...s) {
        for (const e of s) this.h[e].splice(this.h[e].indexOf(t) >>> 0, 1);
        return this;
    }
    i(t) {
        "production" !== process.env.NODE_ENV && 0 === this.t && console.error("trying to add event to batch queue, while _inBatch is 0"), 
        this.l.add(t);
    }
    p(t) {
        if (0 === this.t) for (const s of this.h[t]) s.call(this); else for (const s of this.h[t]) this.l.add(s);
    }
    /* inspired by mobx */    g() {
        this.t++;
    }
    R() {
        if (0 == --this.t) {
            for (const t of this.l) 
            /*
            These callbacks must not call _startBatch from inside.
        */
            t.call(this);
            this.l.clear();
        }
    }
} {
    constructor(...t) {
        super(...t), this._ = 0, this.rowsQuantity = 0, this.C = 0, this.v = 0, this.H = 0, 
        this.N = 0, this.M = null, this.S = null, this.O = null, this.from = 0, this.to = 0, 
        this.P = 0, this.T = 0, this.j = t => {
            /*
          No check is needed here;
          Assuming, that view layer does not trigger this with same value each time
      */
            const s = t.target.scrollTop - this._;
            this._ += s, s > 0 ? this.D() : this.k(), this.M && (this.M.style.height = `${this.P}px`);
        }, this.W = ({offsetHeight: t}) => {
            t !== this.v && (this.v = t, this.D()), this.A();
        }, this.I = t => {
            this.$(), this.S = t, t && (N(t, this.W), t.addEventListener("scroll", this.j, {
                passive: !0
            }));
        }, this.o = t => this.M = t, this.B = t => this.O = t, this.A = ((t, s, e) => {
            let i = 0;
            const o = () => {
                i = 0, t.call(e);
            }, r = () => {
                0 === i && (i = setTimeout(o, s));
            };
            return r.cancel = () => {
                clearTimeout(i), i = 0;
            }, r;
        })(this.K, 300, this);
    }
    $() {
        this.S && (M(this.S), this.S.removeEventListener("scroll", this.j));
    }
    /* will ne used as callback, so => */    L() {
        this.O && (this.O.style.height = this.T + "px");
    }
    q(t) {
        /*
    TODO: DEBUG;
    
    if( delta !== 0 ){
        this._extraStickyHeight += delta;    
        this._updateHeight();
    }
    */}
    D() {
        const t = Math.min(this.rowsQuantity, this.getIndex(this._ + this.v) + 1);
        t >= this.to && (this.from = this.getIndex(this._), this.to = Math.min(this.rowsQuantity, t + this.C), 
        this.P = this.getOffset(this.from), this.p(0));
    }
    k() {
        const t = this.getIndex(this._);
        t <= this.from && (this.from = Math.max(0, t - this.C), this.to = Math.min(this.rowsQuantity, 1 + this.getIndex(this._ + this.v)), 
        this.P = this.getOffset(this.from), this.p(0));
    }
    F() {
        this.to > this.rowsQuantity ? (this.to = this.rowsQuantity, this.p(0)) : this.D();
    }
    u() {
        this.$(), this.A.cancel(), super.u();
    }
    scrollToRow(t) {
        this.S ? this.S.scrollTop = this.getOffset(t) : "production" !== process.env.NODE_ENV && console.error("scrollContainerNode is not set");
    }
    U(t) {
        /*
        TODO: crushes without if check.
    */
        this.T !== t && (this.T = t, this.L());
    }
    V(t, s, e) {
        this.N = t, 
        /*
        No need to waste extra render reacting on this prop.
        Normally it should not be changed.
    */
        this.C = s, e !== this.rowsQuantity && (this.rowsQuantity = e, this.Y(), this.F(), 
        this.A(), this.p(1));
    }
}

class O extends S {
    /*
      most significant bit of this.rowsQuantity;
      caching it to avoid Math.clz32 calculations on every getIndex call
  */
    constructor() {
        super(), this.J = [], this.X = [], this.G = 0, this.on(this.A, 0);
    }
    Y() {
        const {rowsQuantity: t} = this;
        if (t < 0 || t > 2147483647) throw new Error(`Wrong rowsQuantity: ${t}. Must be 0...2_147_483_647.`);
        this.G = t && 1 << 31 - Math.clz32(t);
        const s = this.J.length;
        if (t > s) {
            const e = this.J;
            this.J = new Uint32Array(t), this.X = new Uint32Array(t + 1), this.J.set(e), this.J.fill(this.N, s), 
            /* 
          Creating fenwick tree from an array in linear time;
          It is much more efficient, than calling updateRowHeight N times.
      */
            this.X.set(this.J, 1);
            for (let s, e = 1; e <= t; e++) s = e + (e & -e), s <= t && (this.X[s] += this.X[e]);
        }
        this.U(this.getOffset(t));
    }
    getIndex(t) {
        let s = 0;
        for (let e, i = this.G; 0 !== i; i >>= 1) if (e = s + i, !(e > this.rowsQuantity)) {
            if (t === this.X[e]) return e;
            t > this.X[e] && (t -= this.X[e], s = e);
        }
        return s;
    }
    getOffset(t) {
        if ("production" !== process.env.NODE_ENV && t > this.rowsQuantity) throw new Error("index must not be > rowsQuantity");
        let s = 0;
        for (;t > 0; t -= t & -t) s += this.X[t];
        return s;
    }
    /* i starts from 1 here; */    Z(t, s, e) {
        for (;t < e; t += t & -t) this.X[t] += s;
    }
    K() {
        var t;
        let s = null == (t = this.M) ? void 0 : t.nextElementSibling;
        if (s) {
            let t, e = this.from, i = 0;
            /* We can batch-update fenwick tree, if we know, that all indexes are updated in +1 - order. */            const o = Math.min(this.X.length, 1 << 32 - Math.clz32(this.to - 1));
            do {
                t = s.offsetHeight - this.J[e], t && (this.J[e] += t, i += t, this.Z(e + 1, t, o));
            } while (++e < this.to && (s = s.nextElementSibling));
            0 !== i && (this.Z(o, i, this.X.length), this.U(this.T + i), this.D());
        }
    }
}

class P extends S {
    constructor(...t) {
        super(...t), this.tt = 0;
    }
    st(t) {
        t !== this.tt && (this.tt = t, this.U(t * this.rowsQuantity), this.D());
    }
    Y() {
        0 === this.tt && (this.tt = this.N), this.U(this.tt * this.rowsQuantity);
    }
    getIndex(t) {
        /* rounding via bitwise hacks like |0 may not work here, because number may be > max(int32) */
        return this.tt && Math.trunc(t / this.tt);
    }
    getOffset(t) {
        return t * this.tt;
    }
    K() {
        if (this.rowsQuantity) {
            var t;
            const s = null == (t = this.M) ? void 0 : t.nextElementSibling;
            s && this.st(s.offsetHeight);
        }
    }
}

const Q = "_5e-1cSu", T = "_1V5_Rp3", j = [ "rowsQuantity", "children", "as", "fixed", "estimatedRowHeight", "overscanRowsCount", "dataRef", "className" ], D = [], k = s => {
    let {rowsQuantity: e, children: o, as: n = "div", fixed: l = !1, estimatedRowHeight: a = 20, overscanRowsCount: c = 3, dataRef: f, className: m} = s, p = t(s, j);
    const [w] = r((() => new (l ? P : O)));
    if (w.g(), w.V(a, c, e), i((() => {
        w.R();
    })), i((() => () => w.u()), D), h(f, (() => w), D), "production" !== process.env.NODE_ENV) {
        w instanceof (l ? P : O) || console.warn("\n                'fixed' prop is taken into account ONLY during initial component mount.\n                All future changes are ignored. You must decide once.");
    }
    /*
      tabIndex="0" is for proper keyboard nav
      https://bugzilla.mozilla.org/show_bug.cgi?id=1346159
  */    /*#__PURE__*/
    return d(n, Object.assign({}, p, {
        tabIndex: "0",
        className: y(Q, m),
        ref: w.I,
        children: [ /*#__PURE__*/ u("div", {
            ref: w.B,
            "aria-hidden": "true",
            className: T
        }), o(w) ]
    }));
};

"production" !== process.env.NODE_ENV && (k.propTypes = {
    rowsQuantity: c.number.isRequired,
    Container: c.elementType,
    className: c.string,
    fixed: c.bool,
    overscanRowsCount: c.number,
    estimatedRowHeight: c.number
});

const E = [ "children" ], W = s => {
    let {children: e} = s, i = t(s, E);
    /*#__PURE__*/
    return u(k, Object.assign({}, i, {
        children: t => /*#__PURE__*/ u(x, {
            model: t,
            children: e
        })
    }));
};

"production" !== process.env.NODE_ENV && (W.propTypes = {
    /**
   * @param {number} rowIndex
   * @returns {any} one row element child. Fragments are not supported.
   */
    children: c.func.isRequired
});

const A = /*#__PURE__*/ n(W), I = ({model: t, children: e}) => {
    const i = s(null), o = s(0), r = l((s => {
        i.current && (M(i.current), t.q(-o.current)), s && N(s, (({offsetHeight: s}) => {
            t.q(s - o.current), o.current = s;
        })), i.current = s;
    }), [ t ]);
    /*#__PURE__*/
    return a(e, {
        ref: r
    });
}, $ = ({dataKey: t, background: s, border: e, width: i}) => /*#__PURE__*/ u("col", {
    style: {
        width: i,
        background: s,
        border: e
    }
}, t), B = /*#__PURE__*/ n((({columns: t}) => /*#__PURE__*/ u("colgroup", {
    children: t.map($)
}))), K = ({index: t, columns: s, getRowData: e, getRowProps: i, Cell: o}) => {
    const r = e(t);
    /*#__PURE__*/
    return u("tr", Object.assign({}, i && i(r, t), {
        children: r ? s.map((t => {
            const s = t.Cell || o;
            /*#__PURE__*/
            return u("td", {
                children: /*#__PURE__*/ u(s, {
                    rowData: r,
                    column: t
                })
            }, t.dataKey);
        })) : /*#__PURE__*/ u("td", {
            colSpan: s.length,
            children: " "
        })
    }));
}, L = (t, s) => /*#__PURE__*/ u(s.Row, Object.assign({
    index: t
}, s), t), q = t => t.map((t => /*#__PURE__*/ u("th", {
    style: {
        minWidth: t.minWidth
    },
    children: t.label
}, t.dataKey))), F = ({rowData: t, column: s}) => {
    const {render: e, dataKey: i, format: o} = s, r = t[i];
    return void 0 === r ? " " : e ? e(r, t) : o ? o(r) : r;
}, U = "_1kcsJP_", V = [ "columns", "getRowData", "getRowProps", "renderRow", "Row", "renderHeaderCells", "renderTfootContent", "Cell", "headless", "className" ], Y = s => {
    let {columns: e, getRowData: i, getRowProps: o, renderRow: r, Row: h, renderHeaderCells: n, renderTfootContent: l, Cell: a, headless: c, className: f} = s, m = t(s, V);
    /*#__PURE__*/
    return u(k, Object.assign({
        className: y("afvscr-table", f)
    }, m, {
        children: t => /*#__PURE__*/ d("table", {
            className: U,
            children: [ /*#__PURE__*/ u(B, {
                columns: e
            }), c ? null : /*#__PURE__*/ u(I, {
                model: t,
                children: /*#__PURE__*/ u("thead", {
                    children: /*#__PURE__*/ u("tr", {
                        children: n(e)
                    })
                })
            }), /*#__PURE__*/ u("tbody", {
                children: /*#__PURE__*/ u(x, {
                    model: t,
                    Spacer: "tr",
                    columns: e,
                    getRowData: i,
                    getRowProps: o,
                    Row: h,
                    Cell: a,
                    children: r
                })
            }), l ? /*#__PURE__*/ u(I, {
                model: t,
                children: /*#__PURE__*/ u("tfoot", {
                    children: l(e)
                })
            }) : null ]
        })
    }));
};

"production" !== process.env.NODE_ENV && (Y.propTypes = {
    className: c.string,
    columns: c.arrayOf(c.oneOfType([ c.string, c.shape({
        // unique key for column
        dataKey: c.string.isRequired,
        // for details see CellComponent implementation
        format: c.func,
        render: c.func,
        formatTotal: c.func,
        totals: c.string,
        // column props, affecting colgroup > col tags
        background: c.string,
        border: c.string,
        width: c.oneOfType([ c.number, c.string ]),
        // works pretty shitty in col tag
        minWidth: c.oneOfType([ c.number, c.string ]),
        CellComponent: c.elementType,
        getCellExtraProps: c.func
    }) ])).isRequired,
    getRowData: c.func.isRequired,
    getRowProps: c.func,
    renderTfootContent: c.func,
    renderHeaderCells: c.func,
    Row: c.elementType,
    Cell: c.elementType,
    headless: c.bool
}), Y.defaultProps = {
    headless: !1,
    renderRow: L,
    Row: K,
    renderHeaderCells: q,
    Cell: F
};

const z = /*#__PURE__*/ n(Y), J = (t, s, e = []) => i((() => {
    const e = t.current;
    if (s) {
        const t = () => s(e);
        return t(), e.on(t, 1, 0), () => e.off(t, 1, 0);
    }
}), e);

export { F as Cell, k as Container, g as EVENTS_ARRAY_LENGTH, p as EVT_RANGE, w as EVT_ROWS_QUANTITY, I as ExtraHeight, A as List, K as Row, x as Rows, z as Table, y as cx, q as renderHeaderCells, L as renderRow, J as useRange };
//# sourceMappingURL=index.esm.js.map
