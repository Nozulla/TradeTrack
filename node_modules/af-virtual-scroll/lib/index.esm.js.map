{"version":3,"file":"index.esm.js","sources":["../src/hooks/useSubscription/index.js","../src/constants/events.js","../src/components/common/Rows/index.js","../src/utils/cx/index.js","../src/utils/throttle/index.js","../src/utils/dimensionsObserver/index.js","../src/models/ListBase/index.js","../src/models/PubSub/index.js","../src/models/VariableSizeList/index.js","../src/models/FixedSizeList/index.js","../src/components/common/Container/index.js","../src/components/List/index.js","../src/components/common/ExtraHeight/index.js","../src/components/Table/Colgroup/index.js","../src/components/Table/renderers.js","../src/components/Table/index.js","../src/hooks/useRange/index.js"],"sourcesContent":["import { useRef, useEffect, useReducer } from \"react\";\n\nconst increment = x => x + 1;\n\nconst useForceUpdate = () => useReducer( increment, 0 )[ 1 ];\n\nconst useSubscription = ( model, callBack, events ) => {\n    \n    const prevRenderRef = useRef( null );\n    const forceUpdate = useForceUpdate();\n    \n    useEffect(() => {\n        model.on( forceUpdate, ...events );\n        return () => model.off( forceUpdate, ...events );\n    }, events );\n\n    if( model._inBatch === 0 ){\n        prevRenderRef.current = callBack( model );\n    }\n    else{\n        /*\n            Somebody tried to rerender, while we were in batch.\n            On batch finish component definitely must be rerendered.\n        */\n        model._queue( forceUpdate );\n    }\n    \n    return prevRenderRef.current;\n}\n\nexport default useSubscription;","export const EVT_RANGE                          = 0;\nexport const EVT_ROWS_QUANTITY                  = 1;\nexport const EVENTS_ARRAY_LENGTH                = 2;","import { Fragment } from \"react\";\r\nimport useSubscription from \"hooks/useSubscription\";\r\nimport { EVT_RANGE } from \"constants/events\";\r\nimport css from \"./style.module.scss\";\r\n\r\nconst Events = [ EVT_RANGE ];\r\n\r\nconst VisibleRows = ({ m: model, r: renderRow, e: extraProps }) => useSubscription(\r\n    model, \r\n    ({ from, to }) => {\r\n        const result = [];    \r\n        \r\n        for( let i = from; i < to; i++ ){\r\n            result.push(renderRow( i, extraProps ));\r\n        }\r\n\r\n        return result;\r\n    },\r\n    Events\r\n);\r\n\r\nconst Rows = ({ model, children, Spacer = \"div\", ...rest }) => (\r\n    <Fragment>\r\n        <Spacer\r\n            className={css.spacer}\r\n            aria-hidden=\"true\"\r\n            ref={model._setSpacerNode}\r\n        />\r\n        <VisibleRows\r\n            m={model}\r\n            r={children}\r\n            e={rest}\r\n        />\r\n    </Fragment>\r\n);\r\n\r\n\r\nexport default Rows;","const cx = ( baseClass, extraClass ) => extraClass ? `${baseClass} ${extraClass}` : baseClass;\r\n\r\nexport default cx;","const throttle = ( fn, ms, ctx ) => {\n    let timer = 0;\n\n    const cancel = () => {\n        clearTimeout( timer );\n        timer = 0;\n    }\n\n    const invoke = () => {\n        timer = 0;\n        fn.call( ctx );\n    }\n\n    const throttled = () => {\n        if( timer === 0 ){\n            timer = setTimeout( invoke, ms );\n        }\n    }\n\n    throttled.cancel = cancel;\n\n    return throttled;\n}\n\nexport default throttle;","const callBacks = new Map();\n\nconst R = new ResizeObserver( entries => {\n    for( const { target } of entries ){\n        const cb = callBacks.get( target );\n        cb && cb( target );\n    }\n});\n\nexport const observe = ( el, callBack ) => {\n    callBacks.set( el, callBack );\n    R.observe( el, { box : \"border-box\" });\n}\n\nexport const unobserve = el => callBacks.delete( el ) && R.unobserve( el );","import PubSub from \"../PubSub\";\nimport throttle from \"utils/throttle\";\nimport { observe, unobserve } from \"utils/dimensionsObserver\";\n\nimport {\n    EVT_RANGE,\n    EVT_ROWS_QUANTITY\n} from \"constants/events\";\n\nclass ListBase extends PubSub {\n\n    _scrollTop = 0;\n\n    rowsQuantity = 0;\n    _overscanRowsCount = 0;\n\n    _widgetHeight = 0;\n\n    /* sticky elements ( for example table header/footer ) must influence ONLY on widgetScrollHeight */\n    _extraStickyHeight = 0;\n\n    _estimatedRowHeight = 0;\n\n    _spacerNode = null;\n    _scrollContainerNode = null;\n    _heightNode = null;\n\n\n    /* Calculated inside model */\n    from = 0;\n    to = 0;\n    _virtualTopOffset = 0;\n    _widgetScrollHeight = 0;\n\n    _setScrollTop = e => {\n        /*\n            No check is needed here;\n            Assuming, that view layer does not trigger this with same value each time\n        */\n        const diff = e.target.scrollTop - this._scrollTop;\n        this._scrollTop += diff;\n        if( diff > 0 ){\n            this._updateRangeFromEnd();\n        }\n        else {\n            this._updateRangeFromStart();\n        }\n        if( this._spacerNode ){\n            this._spacerNode.style.height = `${this._virtualTopOffset}px`;\n        }\n    }\n\n    _updateWidgetDimensions = ({ offsetHeight }) => {\n\n        if( offsetHeight !== this._widgetHeight ){\n            this._widgetHeight = offsetHeight;\n            this._updateRangeFromEnd();\n        }\n\n        this._measureRowsThrottled();\n    }\n\n    _unobserveCurrentScrollContainerNode(){\n        if( this._scrollContainerNode ){\n            unobserve( this._scrollContainerNode );\n            this._scrollContainerNode.removeEventListener( \"scroll\", this._setScrollTop );\n        }\n    }\n\n    /* will ne used as callback, so => */\n    _setScrollContainerNode = node => {\n        this._unobserveCurrentScrollContainerNode();\n        this._scrollContainerNode = node;\n        if( node ){\n            observe( node, this._updateWidgetDimensions );\n            node.addEventListener( \"scroll\", this._setScrollTop, { passive: true });\n        }\n    }\n\n    /* will ne used as callback, so => */\n    _setSpacerNode = node => this._spacerNode = node;\n\n    /* will ne used as callback, so => */\n    _setHeightNode = node => this._heightNode = node;\n\n    _updateHeight(){\n        if( this._heightNode ){\n            this._heightNode.style.height = this._widgetScrollHeight + 'px';\n        }\n    }\n\n    _updateExtraStickyHeight( delta ){\n        /*\n        TODO: DEBUG;\n        \n        if( delta !== 0 ){\n            this._extraStickyHeight += delta;    \n            this._updateHeight();\n        }\n        */\n    }\n\n    _updateRangeFromEnd(){\n        const to = Math.min( this.rowsQuantity, this.getIndex( this._scrollTop + this._widgetHeight ) + 1 );\n\n        if( to >= this.to ){\n            this.from = this.getIndex( this._scrollTop );\n            this.to = Math.min( this.rowsQuantity, to + this._overscanRowsCount );\n            this._virtualTopOffset = this.getOffset( this.from );\n            this._emit( EVT_RANGE );\n        }\n    }\n\n    _updateRangeFromStart(){\n        const from = this.getIndex( this._scrollTop );\n\n        if( from <= this.from ){\n            this.from = Math.max( 0, from - this._overscanRowsCount );\n            this.to = Math.min( this.rowsQuantity, 1 + this.getIndex( this._scrollTop + this._widgetHeight ) );\n            this._virtualTopOffset = this.getOffset( this.from );\n            this._emit( EVT_RANGE );\n        }\n    }\n\n    _clampTo(){\n        if( this.to > this.rowsQuantity ){\n            this.to = this.rowsQuantity;\n            this._emit( EVT_RANGE );\n        }\n        else {\n            this._updateRangeFromEnd();\n        }\n    }\n\n    _measureRowsThrottled = throttle( this._measureRows, 300, this );\n\n    _destroy(){\n        this._unobserveCurrentScrollContainerNode();\n        this._measureRowsThrottled.cancel();\n        super._destroy();\n    }\n\n    scrollToRow( rowIndex ){\n        if( this._scrollContainerNode ){\n            this._scrollContainerNode.scrollTop = this.getOffset( rowIndex );\n        }\n        else if( process.env.NODE_ENV !== \"production\" ){\n            console.error( \"scrollContainerNode is not set\" );\n        }\n    }\n\n    _setWidgetScrollHeight( v ){\n        /*\n            TODO: crushes without if check.\n        */\n        if( this._widgetScrollHeight !== v ){\n            this._widgetScrollHeight = v;\n            this._updateHeight();\n        }\n    }\n\n    _setParams( estimatedRowHeight, overscanRowsCount, rowsQuantity ){\n\n        this._estimatedRowHeight = estimatedRowHeight;\n\n        /*\n            No need to waste extra render reacting on this prop.\n            Normally it should not be changed.\n        */\n        this._overscanRowsCount = overscanRowsCount;\n\n        if( rowsQuantity !== this.rowsQuantity ){\n            this.rowsQuantity = rowsQuantity;\n            this._rowsQuantityChanged();\n            this._clampTo();\n            this._measureRowsThrottled();\n            this._emit( EVT_ROWS_QUANTITY );\n        }\n    }\n}\n\nexport default ListBase;","import { EVENTS_ARRAY_LENGTH } from \"constants/events\";\n\nclass PubSub {\n\n    /* All callbacks are known in advance, so we can allocate in construcror */\n    _E = Array.from({ length: EVENTS_ARRAY_LENGTH }, () => []);\n\n    /* query of callbacks, that should run after batch end */\n    _Q = new Set();\n\n    /* depth of batch */\n    _inBatch = 0;\n\n    on( callBack, ...events ){\n        for( const evt of events ){\n            this._E[ evt ].push( callBack );\n        }\n        return this;\n    }\n\n    _destroy(){\n        for( const events of this._E ){\n            events.splice( 0 );\n        }\n        this._Q.clear();\n    }\n\n    off( callBack, ...events ){\n        for( const evt of events ){\n            this._E[ evt ].splice( this._E[ evt ].indexOf( callBack ) >>> 0, 1 );\n        }\n        return this;\n    }\n\n    _queue( cb ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( this._inBatch === 0 ){\n                console.error( \"trying to add event to batch queue, while _inBatch is 0\" );\n            }\n        }\n        this._Q.add( cb );\n    }\n\n    _emit( evt ){\n        if( this._inBatch === 0 ){\n            for( const cb of this._E[ evt ] ){\n                cb.call( this );\n            }\n        }\n        else{\n            for( const cb of this._E[ evt ] ){\n                this._Q.add( cb );\n            }\n        }\n    }\n\n    /* inspired by mobx */\n\n    _startBatch(){\n        this._inBatch++;\n    }\n\n    _endBatch(){\n        if( --this._inBatch === 0 ){\n            for( const cb of this._Q ){\n                /*\n                    These callbacks must not call _startBatch from inside.\n                */\n                cb.call( this );\n            }\n            this._Q.clear();\n        }\n    }\n}\n\nexport default PubSub;","import ListBase from \"../ListBase\";\nimport { EVT_RANGE } from \"constants/events\";\n\nclass VariableSizeList extends ListBase {\n    \n    _rowHeights = [];\n    _fTree = [];\n\n    /*\n        most significant bit of this.rowsQuantity;\n        caching it to avoid Math.clz32 calculations on every getIndex call\n    */\n    _msb = 0;\n    \n    constructor(){\n        super();\n\n        this.on( this._measureRowsThrottled, EVT_RANGE );            \n    }\n\n    _rowsQuantityChanged(){\n\n        const { rowsQuantity } = this;\n\n        if( rowsQuantity < 0 || rowsQuantity > 0x7fffffff ){\n            throw new Error( `Wrong rowsQuantity: ${rowsQuantity}. Must be 0...2_147_483_647.` )\n        }\n\n        this._msb = rowsQuantity && 1 << 31 - Math.clz32( rowsQuantity );\n\n        const curRowHeighsLength = this._rowHeights.length;\n\n        if( rowsQuantity > curRowHeighsLength ){\n\n            const oldRowHeights = this._rowHeights;\n            \n            this._rowHeights = new Uint32Array( rowsQuantity );\n            this._fTree = new Uint32Array( rowsQuantity + 1 );\n\n            this._rowHeights.set( oldRowHeights );\n            this._rowHeights.fill( this._estimatedRowHeight, curRowHeighsLength );\n\n\n            /* \n                Creating fenwick tree from an array in linear time;\n                It is much more efficient, than calling updateRowHeight N times.\n            */\n\n            this._fTree.set( this._rowHeights, 1 );\n\n            for( let i = 1, j; i <= rowsQuantity; i++ ){\n                j = i + ( i & -i );\n                if( j <= rowsQuantity ){\n                    this._fTree[ j ] += this._fTree[ i ];\n                }\n            }\n        }\n\n        this._setWidgetScrollHeight( this.getOffset( rowsQuantity ) );\n    }\n\n    getIndex( offset ){\n        let index = 0;\n        \n        for( let bitMask = this._msb, tempIndex; bitMask !== 0; bitMask >>= 1 ){\n            tempIndex = index + bitMask;\n            if( tempIndex > this.rowsQuantity ){\n                continue;\n            }\n            if( offset === this._fTree[ tempIndex ] ){\n                return tempIndex;\n            }\n            if( offset > this._fTree[ tempIndex ] ) {\n                offset -= this._fTree[ tempIndex ];\n                index = tempIndex;\n            }\n        }\n\n        return index;\n    }\n\n    getOffset( index ){\n        if( process.env.NODE_ENV !== \"production\" ){\n            if( index > this.rowsQuantity ){\n                throw new Error( \"index must not be > rowsQuantity\" );\n            }\n        }\n\n        let result = 0;\n\n        for ( ; index > 0; index -= index & -index ){\n            result += this._fTree[ index ];\n        }\n\n        return result;\n    }\n\n    /* i starts from 1 here; */\n    _updateRowHeight( i, delta, limitTreeLiftingIndex ){\n        for ( ; i < limitTreeLiftingIndex; i += i & -i ){\n            this._fTree[ i ] += delta;\n        }\n    }\n\n    _measureRows(){\n        let child = this._spacerNode?.nextElementSibling;\n\n        if( child ){\n\n            let index = this.from,\n                diff,\n                buff = 0;\n            \n            /* We can batch-update fenwick tree, if we know, that all indexes are updated in +1 - order. */\n            const lim = Math.min( this._fTree.length, 1 << 32 - Math.clz32( this.to - 1 ) );\n\n            do {\n                diff = child.offsetHeight - this._rowHeights[ index ];\n\n                if( diff ){\n                    this._rowHeights[ index ] += diff;\n                    buff += diff;\n                    this._updateRowHeight( index + 1, diff, lim );                  \n                }                \n            }\n            while( ++index < this.to && ( child = child.nextElementSibling ) );\n\n            if( buff !== 0 ){\n                this._updateRowHeight( lim, buff, this._fTree.length );\n                this._setWidgetScrollHeight( this._widgetScrollHeight + buff );\n                this._updateRangeFromEnd();\n            }\n        }\n    }\n}\n\nexport default VariableSizeList;","import ListBase from \"../ListBase\";\n\nclass FixedSizeList extends ListBase {\n\n    _rowHeight = 0;\n\n    _setRowHeight( v ){\n        if( v !== this._rowHeight ){\n            this._rowHeight = v;\n            this._setWidgetScrollHeight( v * this.rowsQuantity );\n            this._updateRangeFromEnd();\n        }\n    }\n\n    _rowsQuantityChanged(){\n        if( this._rowHeight === 0 ){\n            this._rowHeight = this._estimatedRowHeight;\n        }\n        this._setWidgetScrollHeight( this._rowHeight * this.rowsQuantity );\n    }\n\n    getIndex( offset ){\n        /* rounding via bitwise hacks like |0 may not work here, because number may be > max(int32) */\n        return this._rowHeight && Math.trunc( offset / this._rowHeight );\n    }\n\n    getOffset( index ){\n        return index * this._rowHeight;\n    }\n\n    _measureRows(){\n        if( this.rowsQuantity ){\n            const tgtEl = this._spacerNode?.nextElementSibling;\n            \n            if( tgtEl ){\n                this._setRowHeight( tgtEl.offsetHeight );\n            }   \n        }\n    }    \n}\n\nexport default FixedSizeList;","import { useState, useEffect, useImperativeHandle } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport cx from \"utils/cx\";\r\nimport VariableHeightsModel from \"models/VariableSizeList\";\r\nimport FixedHeightsModel from \"models/FixedSizeList\";\r\nimport css from \"./style.module.scss\";\r\n\r\nconst EMPTY_ARRAY = [];\r\n\r\nconst Container = ({\r\n    rowsQuantity,\r\n    children,\r\n    as: Component = \"div\",\r\n    fixed = false,\r\n    estimatedRowHeight = 20,\r\n    overscanRowsCount = 3,\r\n    dataRef,\r\n    className,\r\n    ...props\r\n}) => {\r\n    \r\n    const [ model ] = useState(() => new ( fixed ? FixedHeightsModel : VariableHeightsModel ));\r\n\r\n    model._startBatch();\r\n    model._setParams( estimatedRowHeight, overscanRowsCount, rowsQuantity );\r\n\r\n    useEffect(() => {\r\n        model._endBatch();\r\n    });\r\n\r\n    useEffect(() => () => model._destroy(), EMPTY_ARRAY);\r\n\r\n    useImperativeHandle( dataRef, () => model, EMPTY_ARRAY);\r\n\r\n    if( process.env.NODE_ENV !== \"production\" ){\r\n        const AssumedConstructor = fixed ? FixedHeightsModel : VariableHeightsModel;\r\n        if( !( model instanceof AssumedConstructor ) ){\r\n            console.warn( `\r\n                'fixed' prop is taken into account ONLY during initial component mount.\r\n                All future changes are ignored. You must decide once.`\r\n            );\r\n        }\r\n    }\r\n    \r\n    /*\r\n        tabIndex=\"0\" is for proper keyboard nav\r\n        https://bugzilla.mozilla.org/show_bug.cgi?id=1346159\r\n    */\r\n    return (\r\n        <Component\r\n            {...props}\r\n            tabIndex=\"0\"\r\n            className={cx(css.wrapper,className)}\r\n            ref={model._setScrollContainerNode}\r\n        >\r\n            <div\r\n                ref={model._setHeightNode}\r\n                aria-hidden=\"true\"\r\n                className={css.heightNode}\r\n            />\r\n            {children( model )}\r\n        </Component>\r\n    );\r\n};\r\n\r\nContainer.propTypes = {\r\n    rowsQuantity: PropTypes.number.isRequired,\r\n    Container: PropTypes.elementType,\r\n    className: PropTypes.string,\r\n    fixed: PropTypes.bool,\r\n    overscanRowsCount: PropTypes.number,\r\n    estimatedRowHeight: PropTypes.number,\r\n}\r\n\r\nexport default Container;","import { memo } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\n\r\nimport Rows from \"../common/Rows\";\r\nimport Container from \"../common/Container\";\r\n\r\nconst List = ({ children, ...props }) => (\r\n    <Container {...props}>\r\n        {model => <Rows model={model}>{children}</Rows>}\r\n    </Container>\r\n);\r\n\r\nList.propTypes = {\r\n    /**\r\n     * @param {number} rowIndex\r\n     * @returns {any} one row element child. Fragments are not supported.\r\n     */\r\n    children: PropTypes.func.isRequired\r\n}\r\n\r\nexport default memo( List );","import { useRef, useCallback, cloneElement } from \"react\";\nimport { observe, unobserve } from \"utils/dimensionsObserver\";\n\nconst ExtraHeight = ({ model, children }) => {\n\n    const prevEl = useRef( null );\n    const prevHeight = useRef( 0 );\n\n    const updateRef = useCallback( el => {\n        \n        if( prevEl.current ){\n            unobserve( prevEl.current );\n            model._updateExtraStickyHeight( -prevHeight.current );\n        }\n\n        if( el ){\n            observe( el, ({ offsetHeight }) => {\n                model._updateExtraStickyHeight( offsetHeight - prevHeight.current );\n                prevHeight.current = offsetHeight;\n            });\n        }\n\n        prevEl.current = el;\n    }, [ model ]);\n\n    return cloneElement( children, { ref: updateRef });\n}\n\nexport default ExtraHeight;","import { memo } from \"react\";\r\n\r\nconst mapper = ({ dataKey, background, border, width }) => (\r\n    <col\r\n        key={dataKey}\r\n        style={{\r\n            width,\r\n            background,\r\n            border\r\n        }}\r\n    />\r\n);\r\n\r\nconst Colgroup = ({ columns }) => (\r\n    <colgroup>\r\n        {columns.map( mapper )}\r\n    </colgroup>\r\n);\r\n\r\nexport default memo( Colgroup );","/*\n    If all cells in a row would be completely empty - row can \"collapse\" short.\n    To prevent it we can fill it with &nbsp;\n*/\nconst DEFAULT_EMPTY_CELL_CONTENT = \"\\u00A0\";\n\nexport const Row = ({ index, columns, getRowData, getRowProps, Cell }) => {\n\n    const rowData = getRowData( index );\n\n    return (\n        <tr {...(getRowProps&&getRowProps(rowData,index))}>\n            {rowData ? columns.map( column => {\n                const FinalCell = column.Cell || Cell;\n                return (\n                    <td key={column.dataKey}>\n                        <FinalCell rowData={rowData} column={column} />\n                    </td>\n                );\n            }) : (\n                <td colSpan={columns.length}>\n                    {DEFAULT_EMPTY_CELL_CONTENT}\n                </td>\n            )}\n        </tr>\n    );\n}\n\nexport const renderRow = ( index, RowProps ) => <RowProps.Row key={index} index={index} {...RowProps} />\n\nexport const renderHeaderCells = columns => columns.map( column => (\n    <th key={column.dataKey} style={{ minWidth: column.minWidth }}>\n        {column.label}\n    </th>\n));\n\nexport const Cell = ({ rowData, column }) => {\n    const { render, dataKey, format } = column;\n\n    const cellData = rowData[ dataKey ];\n    \n    if( cellData === undefined ){\n        return DEFAULT_EMPTY_CELL_CONTENT;\n    }\n\n    if( render ){\n        return render( cellData, rowData );\n    }\n\n    if( format ){\n        return format( cellData );\n    }\n\n    return cellData;\n}","import { memo } from \"react\";\r\nimport PropTypes from \"prop-types\";\r\nimport cx from \"utils/cx\";\r\n\r\nimport Rows from \"../common/Rows\";\r\nimport Container from \"../common/Container\";\r\nimport ExtraHeight from \"../common/ExtraHeight\";\r\n\r\nimport Colgroup from \"./Colgroup\";\r\n\r\nimport {\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    Cell\r\n} from \"./renderers\";\r\n\r\nimport \"./style.scss\";\r\nimport css from \"./style.module.scss\";\r\n\r\n/*\r\n    Todo:\r\n        * think about border-collapse offsetHeight issue ( maybe throw border-collapse )\r\n*/\r\n\r\nconst Table = ({\r\n    columns,\r\n    getRowData,\r\n    getRowProps,\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    renderTfootContent,\r\n    Cell,\r\n    headless,\r\n    className,\r\n    ...props\r\n}) => (\r\n    <Container className={cx(\"afvscr-table\",className)} {...props}>\r\n        {model => (\r\n            <table className={css.bodyTable}>\r\n                <Colgroup columns={columns} />\r\n                {headless ? null : (\r\n                    <ExtraHeight model={model}>\r\n                        <thead>\r\n                            <tr>\r\n                                {renderHeaderCells(columns)}\r\n                            </tr>\r\n                        </thead>\r\n                    </ExtraHeight>\r\n                )}\r\n                <tbody>\r\n                    <Rows\r\n                        model={model}\r\n                        Spacer=\"tr\"\r\n                        columns={columns}\r\n                        getRowData={getRowData}\r\n                        getRowProps={getRowProps}\r\n                        Row={Row}\r\n                        Cell={Cell}\r\n                    >\r\n                        {renderRow}\r\n                    </Rows>\r\n                </tbody>\r\n                {renderTfootContent ? (\r\n                    <ExtraHeight model={model}>\r\n                        <tfoot>\r\n                            {renderTfootContent( columns )}\r\n                        </tfoot>\r\n                    </ExtraHeight>\r\n                ) : null}\r\n            </table>\r\n        )}\r\n    </Container>\r\n);\r\n\r\nTable.propTypes = {\r\n    className: PropTypes.string,\r\n    columns: PropTypes.arrayOf(\r\n        PropTypes.oneOfType([\r\n            PropTypes.string,\r\n                PropTypes.shape({\r\n                // unique key for column\r\n                dataKey: PropTypes.string.isRequired,\r\n\r\n                // for details see CellComponent implementation\r\n                format: PropTypes.func,\r\n                render: PropTypes.func,\r\n                formatTotal: PropTypes.func,\r\n                totals: PropTypes.string,\r\n\r\n                // column props, affecting colgroup > col tags\r\n                background: PropTypes.string,\r\n                border: PropTypes.string,\r\n                width: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\r\n                \r\n                // works pretty shitty in col tag\r\n                minWidth: PropTypes.oneOfType([ PropTypes.number, PropTypes.string ]),\r\n                CellComponent: PropTypes.elementType,\r\n                getCellExtraProps: PropTypes.func\r\n            })\r\n        ])\r\n    ).isRequired,\r\n\r\n    getRowData: PropTypes.func.isRequired,\r\n    getRowProps: PropTypes.func,\r\n    renderTfootContent: PropTypes.func,\r\n    renderHeaderCells: PropTypes.func,\r\n    Row: PropTypes.elementType,\r\n    Cell: PropTypes.elementType,\r\n\r\n    headless: PropTypes.bool,\r\n};\r\n\r\n\r\nTable.defaultProps = {\r\n    headless: false,\r\n\r\n    renderRow,\r\n    Row,\r\n    renderHeaderCells,\r\n    Cell\r\n};\r\n\r\nexport default memo( Table );","import { useEffect } from \"react\";\nimport {\n    EVT_RANGE,\n    EVT_ROWS_QUANTITY\n} from \"constants/events\";\n\nconst useRange = ( modelRef, event, deps = [] ) => useEffect(() => {\n    const model = modelRef.current;\n    if( event ){\n        const evt = () => event( model );\n        evt();\n        model.on( evt, EVT_ROWS_QUANTITY, EVT_RANGE );\n        return () => model.off( evt, EVT_ROWS_QUANTITY, EVT_RANGE );\n    }\n}, deps );\n\nexport default useRange;"],"names":["increment","x","useSubscription","model","callBack","events","prevRenderRef","useRef","forceUpdate","useReducer","useEffect","on","off","_inBatch","current","_queue","EVT_RANGE","EVT_ROWS_QUANTITY","EVENTS_ARRAY_LENGTH","Events","VisibleRows","m","r","renderRow","e","extraProps","from","to","result","i","push","Rows","_ref","children","Spacer","rest","_jsxs","Fragment","_jsx","className","css","ref","_setSpacerNode","cx","baseClass","extraClass","callBacks","Map","R","ResizeObserver","entries","target","cb","get","observe","el","set","box","unobserve","delete","ListBase","_E","Array","length","_Q","Set","evt","this","_destroy","splice","clear","indexOf","process","env","NODE_ENV","console","error","add","_emit","call","_startBatch","_endBatch","_scrollTop","rowsQuantity","_overscanRowsCount","_widgetHeight","_extraStickyHeight","_estimatedRowHeight","_spacerNode","_scrollContainerNode","_heightNode","_virtualTopOffset","_widgetScrollHeight","_setScrollTop","diff","scrollTop","_updateRangeFromEnd","_updateRangeFromStart","style","height","_updateWidgetDimensions","offsetHeight","_measureRowsThrottled","_setScrollContainerNode","node","_unobserveCurrentScrollContainerNode","addEventListener","passive","_setHeightNode","fn","ms","ctx","timer","invoke","throttled","setTimeout","cancel","clearTimeout","throttle","_measureRows","removeEventListener","_updateHeight","_updateExtraStickyHeight","delta","Math","min","getIndex","getOffset","max","_clampTo","scrollToRow","rowIndex","_setWidgetScrollHeight","v","_setParams","estimatedRowHeight","overscanRowsCount","_rowsQuantityChanged","VariableSizeList","constructor","_rowHeights","_fTree","_msb","Error","clz32","curRowHeighsLength","oldRowHeights","Uint32Array","fill","j","offset","index","tempIndex","bitMask","_updateRowHeight","limitTreeLiftingIndex","child","_this$_spacerNode","nextElementSibling","buff","lim","FixedSizeList","_rowHeight","_setRowHeight","trunc","tgtEl","EMPTY_ARRAY","Container","as","Component","fixed","dataRef","props","useState","FixedHeightsModel","VariableHeightsModel","useImperativeHandle","warn","tabIndex","propTypes","PropTypes","number","isRequired","elementType","string","bool","List","func","memo","ExtraHeight","prevEl","prevHeight","updateRef","useCallback","cloneElement","mapper","dataKey","background","border","width","columns","map","Row","getRowData","getRowProps","Cell","rowData","column","FinalCell","colSpan","RowProps","renderHeaderCells","minWidth","label","render","format","cellData","undefined","Table","renderTfootContent","headless","Colgroup","arrayOf","oneOfType","shape","formatTotal","totals","CellComponent","getCellExtraProps","defaultProps","useRange","modelRef","event","deps"],"mappings":"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"}